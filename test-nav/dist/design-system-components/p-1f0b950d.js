let t;var s;(s=t||(t={})).None="0",s.Left="left",s.Right="right",s.Up="up",s.Down="down";const e=Object.freeze({Horizontal:[t.Left,t.Right],Vertical:[t.Up,t.Down],All:[t.Left,t.Right,t.Up,t.Down,t.None]});let i;var n;let h;var o;let r;var a;(n=i||(i={})).Inactive="inactive",n.Active="active",n.Blocked="blocked",(o=h||(h={})).NoPointer="nopointer",o.SinglePointer="singlepointer",o.DualPointer="dualpointer",(a=r||(r={})).NoActiveGesture="noactivegesture",a.ActiveGesture="activegesture";class c{constructor(t,s){this.x=t,this.y=s}}class l{constructor(s,e){this.startPoint=s,this.endPoint=e,this.direction=t.None,this.deltaX=this.endPoint.x-this.startPoint.x,this.deltaY=this.endPoint.y-this.startPoint.y,this.x=this.deltaX,this.y=this.deltaY,this.vectorLength=Math.sqrt(Math.pow(this.deltaX,2)+Math.pow(this.deltaY,2)),Math.abs(this.deltaX)>Math.abs(this.deltaY)?this.startPoint.x<this.endPoint.x?this.direction=t.Right:this.startPoint.x>this.endPoint.x&&(this.direction=t.Left):this.startPoint.y<this.endPoint.y?this.direction=t.Down:this.startPoint.y>this.endPoint.y&&(this.direction=t.Up)}}class u{static getVector(t,s){const e=new c(t.clientX,t.clientY),i=new c(s.clientX,s.clientY);return new l(e,i)}static getSpeed(t,s,e){let i=0;const n=(e-s)/1e3;return null!=t&&0!=n&&(i=t.vectorLength/n),i}static calculateRotationAngle(t,s){const e=new l(t.startPoint,s.startPoint),i=new l(t.endPoint,s.endPoint),n=new c(0,0),h=new l(e.startPoint,n),o=this.translatePoint(e.endPoint,h),r=new l(i.startPoint,n),a=this.translatePoint(i.endPoint,r),u=-1*this.calcAngleRad(o),d=a.x*Math.cos(u)-a.y*Math.sin(u),p=Math.round(a.x*Math.sin(u)+a.y*Math.cos(u));return 180*Math.atan2(p,d)/Math.PI}static calculateVectorAngle(t,s){let e=0;if(t.vectorLength>0&&s.vectorLength>0){const i=Math.acos((t.x*s.x+t.y*s.y)/(t.vectorLength*s.vectorLength));e=this.rad2deg(i)}return e}static translatePoint(t,s){return new c(t.x+s.x,t.y+s.y)}static calcAngleDegrees(t){let s=180*Math.atan2(t.y,t.x)/Math.PI;return s<0&&(s=360+s),s}static calcAngleRad(t){let s=Math.atan2(t.y,t.x);return s<0&&(s=2*Math.PI+s),s}static deg2rad(t){return Math.PI/180*t}static rad2deg(t){return t/(Math.PI/180)}static getCenter(t,s){return new c((t.x+s.x)/2,(t.y+s.y)/2)}static getCenterMovementVector(t,s){const e=this.getCenter(t.startPoint,s.startPoint),i=this.getCenter(t.endPoint,s.endPoint);return new l(e,i)}static calculateDistanceChange(t,s){const e=new l(t.startPoint,s.startPoint);return new l(t.endPoint,s.endPoint).vectorLength-e.vectorLength}static calculateAbsoluteDistanceChange(t,s){const e=this.calculateDistanceChange(t,s);return Math.abs(e)}static calculateRelativeDistanceChange(t,s){const e=new l(t.startPoint,s.startPoint);return new l(t.endPoint,s.endPoint).vectorLength/e.vectorLength}}let d;var p;(p=d||(d={})).Active="active",p.Removed="removed",p.Canceled="canceled";class v{constructor(t,s){this.options={DEBUG:!1,...s},this.DEBUG=this.options.DEBUG;const e=(new Date).getTime();this.pointerId=t.pointerId,this.vectorTimespan=this.options.vectorTimespan??100,this.initialPointerEvent=t,this.currentPointerEvent=t,this.recognizedEvents=[t],this.state=d.Active;const i=u.getVector(t,t);this.parameters={global:{startX:this.initialPointerEvent.clientX,startY:this.initialPointerEvent.clientY,vector:i,deltaX:0,deltaY:0,startTimestampUTC:e,startTimestamp:this.initialPointerEvent.timeStamp,currentTimestamp:this.initialPointerEvent.timeStamp,endTimestamp:null,maximumSpeed:0,currentSpeed:0,distance:0,maximumDistance:0,averageSpeed:0,finalSpeed:0,traveledDistance:0,hasBeenMoved:!1,duration:0},live:{duration:0,speed:0,vector:i,distance:0,isMoving:!1}}}getTarget(){return this.initialPointerEvent.target}reset(){}onIdle(){const t=(new Date).getTime();this.parameters.global.duration=t-this.parameters.global.startTimestampUTC}onPointerMove(t){this.parameters.global.hasBeenMoved=!0,this.parameters.live.isMoving=!0,this.update(t)}onPointerUp(t){this.parameters.global.finalSpeed=this.parameters.live.speed,this.parameters.live.speed=0,this.parameters.live.isMoving=!1,this.state=d.Removed,this.parameters.global.endTimestamp=t.timeStamp,this.update(t),!0===this.DEBUG&&console.log(`[PointerInput] pointerdown ended. pointerdown duration: ${this.parameters.global.duration}ms`)}onPointerLeave(t){this.onPointerUp(t)}onPointerCancel(t){this.update(t),this.parameters.live.speed=0,this.state=d.Canceled,this.parameters.live.isMoving=!1,this.parameters.global.endTimestamp=t.timeStamp,!0===this.DEBUG&&console.log(`[PointerInput] canceled, pointerdown duration:${this.parameters.global.duration}ms`)}update(t){this.currentPointerEvent=t,this.recognizedEvents.push(t);const s=this.getTimedPointerEvents(),e=u.getVector(s[0],s[1]);this.parameters.live.vector=e,this.parameters.live.distance=e.vectorLength,this.parameters.live.speed=u.getSpeed(e,s[0].timeStamp,s[1].timeStamp),this.parameters.live.speed>this.parameters.global.maximumSpeed&&(this.parameters.global.maximumSpeed=this.parameters.live.speed),this.parameters.global.currentTimestamp=t.timeStamp,this.parameters.global.duration=t.timeStamp-this.parameters.global.startTimestamp,this.parameters.global.deltaX=e.endPoint.x-this.parameters.global.startX,this.parameters.global.deltaY=e.endPoint.y-this.parameters.global.startY;const i=u.getVector(this.initialPointerEvent,this.currentPointerEvent);this.parameters.global.vector=i,this.parameters.global.distance=i.vectorLength,i.vectorLength>this.parameters.global.maximumDistance&&(this.parameters.global.maximumDistance=i.vectorLength),!0===this.DEBUG&&(console.log(`[PointerInput] current speed: ${this.parameters.live.speed}px/s`),console.log(`[PointerInput] pointerdown duration: ${this.parameters.global.duration}ms`),console.log(`[PointerInput] live vector length within vectorTimespan: ${this.parameters.live.vector.vectorLength}px`))}getTimedPointerEvents(){let t=this.initialPointerEvent;const s=this.recognizedEvents[this.recognizedEvents.length-1];let e=this.recognizedEvents.length-1,i=0;const n=s.timeStamp;for(;i<this.vectorTimespan&&(e-=1,!(e<0));)t=this.recognizedEvents[e],i=n-t.timeStamp;const h=[t,s];return this.recognizedEvents=this.recognizedEvents.slice(-20),h}}class g{constructor(t){this.pointer=t,this.parameters=t.parameters}getTarget(){return this.pointer.initialPointerEvent.target}getCurrentPointerEvent(){return this.pointer.currentPointerEvent}getCurrentDirection(){return this.parameters.live.vector.direction}onIdle(){}onPointerMove(t){}onPointerUp(t){}onPointerLeave(t){}onPointerCancel(t){}}const P=globalThis.window;let f;f=P?.CustomEvent?P.CustomEvent:class extends Event{constructor(t,s){super(t,s),this.detail=s?.detail}initCustomEvent(){throw new Error("Unsupported deprecated method")}};class m extends f{}class w{constructor(t,s){this.state=i.Inactive,this.validPointerManagerState=null,this.validPointerInputConstructor=g,this.domElement=t,this.initialPointerEvent=null,this.initialParameters=null,this.activeStateParameters=null,this.options={bubbles:!0,blocks:[],supportedDirections:[],supportedButtons:[],DEBUG:!1,...s},this.DEBUG=this.options.DEBUG}getEmptyGestureParameters(){return{global:{min:{},max:{},boolean:{}},live:{min:{},max:{},boolean:{}}}}getGestureParameters(){let t;if(this.state==i.Active?(t=this.activeStateParameters,1==this.DEBUG&&(console.log(`[${this.eventBaseName}] validating using activeStateParameters`),console.log(t))):(1==this.DEBUG&&console.log(`[${this.eventBaseName}] validating using initialParameters`),t=this.initialParameters),null==t)throw new Error("[Gesture] no gesture parameters found. Do not call .getGestureParameters on abstract class Gesture");return t}validateGestureParameters(t){const s=this.getGestureParameters();let e,i=!0;for(e in s){const n=s[e],h=t.parameters[e];let o;for(o in n){const t=n[o];let s;for(s in t){const n=t[s],r=h[s];if(1==this.DEBUG&&console.log(`[${this.eventBaseName}] validating ${e} ${o}: required: ${n}, pointer: ${r}`),"boolean"==typeof n&&"boolean"==typeof r?i=this.validateBooleanParameter(n,r):"number"==typeof n&&"number"==typeof r&&(i=this.validateMinMaxParameter(n,r,o)),0==i)return 1==this.DEBUG&&console.log(`[${this.eventBaseName}] invalidated `),!1}}}return!0}validateBooleanParameter(t,s){return null==t||(t==s?(1==this.DEBUG&&console.log(`validated: required value: ${t}, current value: ${s}`),!0):(1==this.DEBUG&&console.log(`dismissing ${this.eventBaseName}: required value: ${t}, current value: ${s}`),!1))}validateMinMaxParameter(t,s,e){if("min"==e){if(s>=t)return!0}else if("max"==e&&s<=t)return!0;return!1}validateDirection(t){const s=t.getCurrentDirection();return!(this.options.supportedDirections.length&&!this.options.supportedDirections.includes(s)&&(1==this.DEBUG&&console.log(`[Gestures] dismissing ${this.eventBaseName}: supported directions: ${this.options.supportedDirections}, current direction: ${s}`),1))}validateGestureState(){return this.state!=i.Blocked}validatePointerManagerState(t){return t.state==this.validPointerManagerState||(1==this.DEBUG&&console.log(`[Gesture] PointerManagerState invalidated ${this.eventBaseName}: ${t.state}`),!1)}validatePointerInputConstructor(t){return t instanceof this.validPointerInputConstructor||(1==this.DEBUG&&console.log(`[Gesture] PointerInputConstructor invalidated ${this.eventBaseName}: ${this.validPointerInputConstructor}`),!1)}validate(t){let s=this.validateGestureState();1==s&&(s=this.validatePointerManagerState(t));const e=t.activePointerInput;return 1==s&&null!=e&&(s=this.validatePointerInputConstructor(e),1==s&&(s=this.validateDirection(e)),1==s&&(s=this.validateGestureParameters(e))),s}recognize(t){const s=this.validate(t);1==s&&this.state==i.Inactive&&this.onStart(t),1==s&&this.state==i.Active?(null==this.initialPointerEvent&&this.setInitialPointerEvent(t),this.emit(t)):this.state==i.Active&&0==s?this.onEnd(t):1==this.DEBUG&&console.log(`not firing event ${this.eventBaseName}. No SinglePointerInput found`)}getPointerInput(t){if(1==t.hasPointersOnSurface()&&t.activePointerInput instanceof this.validPointerInputConstructor)return t.activePointerInput;if(t.lastRemovedPointer instanceof v){const s=t.getlastRemovedPointerInput();if(s instanceof this.validPointerInputConstructor)return s}return null}setInitialPointerEvent(t){const s=this.getPointerInput(t);if(s instanceof this.validPointerInputConstructor){const t=s.getCurrentPointerEvent();this.initialPointerEvent=t}}emit(s,e){e=e||this.eventBaseName,!0===this.DEBUG&&console.log(`[Gestures] detected and firing event ${e}`);const i=this.getPointerInput(s);if(null!=i){const n=i.getTarget();if(n instanceof EventTarget){const h=this.getEventData(i,s),o={detail:h,bubbles:this.options.bubbles};!0===this.DEBUG&&console.log(o);const r=new m(e,o);1==o.bubbles?n.dispatchEvent(r):this.domElement.dispatchEvent(r);const a=h.live.direction;if(1==!!this.options.supportedDirections&&a!=t.None&&(e==this.eventBaseName||"swipe"==e))for(let t=0;t<this.options.supportedDirections.length;t++){const s=this.options.supportedDirections[t];if(s==a){const t=e+s;1==this.DEBUG&&console.log(`[Gestures] detected and firing event ${t}`);const i=new m(t,o);1==o.bubbles?n.dispatchEvent(i):this.domElement.dispatchEvent(i)}}}}}onStart(t){this.blockGestures(),this.state=i.Active,this.setInitialPointerEvent(t),this.emit(t,`${this.eventBaseName}start`)}onEnd(t){this.unblockGestures(),1==this.DEBUG&&console.log(`[${this.eventBaseName}] ended. Setting ${this.eventBaseName}.state = ${i.Inactive}`),this.state=i.Inactive,this.emit(t,`${this.eventBaseName}end`)}onTouchStart(t){}onTouchMove(t){}onTouchEnd(t){}onTouchCancel(t){}block(t){-1==this.options.blocks.indexOf(t)&&this.options.blocks.push(t)}unblock(t){-1!=this.options.blocks.indexOf(t)&&this.options.blocks.splice(this.options.blocks.indexOf(t),1)}blockGestures(){for(let t=0;t<this.options.blocks.length;t++){const s=this.options.blocks[t];s.state==i.Inactive&&(0==this.DEBUG&&console.log(`[Gesture] blocking ${s.eventBaseName}`),s.state=i.Blocked)}}unblockGestures(){for(let t=0;t<this.options.blocks.length;t++)this.options.blocks[t].state=i.Inactive}getEventData(t,s){throw new Error("Gesture subclasses require a getEventData method()")}}class M extends w{constructor(t,s){super(t,s),this.initialPointerEvent=null,this.validPointerManagerState=h.SinglePointer;const e=this.getEmptyGestureParameters();this.initialParameters={...e},this.activeStateParameters=JSON.parse(JSON.stringify({...e}))}getEventData(t,s){const e=t.parameters.live,i=t.parameters.live;let n=e.vector,h=e.duration;if(null!=this.initialPointerEvent){const s=new c(this.initialPointerEvent.clientX,this.initialPointerEvent.clientY),e=new c(t.pointer.currentPointerEvent.clientX,t.pointer.currentPointerEvent.clientY);n=new l(s,e),h=t.pointer.currentPointerEvent.timeStamp-this.initialPointerEvent.timeStamp}return{recognizer:this,global:{deltaX:n.x,deltaY:n.y,distance:n.vectorLength,speedX:n.x/h,speedY:n.y/h,speed:n.vectorLength/h,direction:n.direction,scale:1,rotation:0,center:{x:e.vector.endPoint.x,y:e.vector.endPoint.y},srcEvent:t.pointer.currentPointerEvent},live:{deltaX:i.vector.x,deltaY:i.vector.y,distance:i.vector.vectorLength,speedX:i.vector.x/t.pointer.vectorTimespan,speedY:i.vector.y/t.pointer.vectorTimespan,speed:i.speed,direction:i.vector.direction,scale:1,rotation:0,center:{x:i.vector.endPoint.x,y:i.vector.endPoint.y},srcEvent:t.pointer.currentPointerEvent},pointerManager:s}}validateButton(t){if(this.options.supportedButtons.length>0){const s=t.activePointerInput,e=t.lastRemovedPointer;let i=null;if(null!=s?i=s.getCurrentPointerEvent():null!=e&&(i=e.currentPointerEvent),null!=i&&"mouse"==i.pointerType&&-1==this.options.supportedButtons.indexOf(i.buttons))return 1==this.DEBUG&&console.log(`dismissing ${this.eventBaseName}: supportedButtons: ${this.options.supportedButtons.toString()}, poinerEvent.buttons: ${i.buttons}`),!1}return!0}validate(t){let s=this.validateButton(t);return 1==s&&(s=super.validate(t)),s}}class $ extends M{constructor(t,s){super(t,s),this.validPointerManagerState=h.NoPointer,this.eventBaseName="tap";let e=200,i=30,n=30;s&&("maxDuration"in s&&(e=s.maxDuration),"maxDistance"in s&&(i=s.maxDistance,n=s.maxDistance)),this.initialParameters.global.max.duration=e,this.initialParameters.live.max.distance=i,this.initialParameters.global.max.distance=n}validateButton(t){if(this.options.supportedButtons.length>0){const s=t.lastRemovedPointer;if(null!=s){const t=s.currentPointerEvent;if("mouse"==t.pointerType&&-1==this.options.supportedButtons.indexOf(t.button))return 1==this.DEBUG&&console.log(`dismissing ${this.eventBaseName}: supportedButtons: ${this.options.supportedButtons.toString()}, poinerEvent.button: ${t.button}`),!1}}return!0}validate(t){let s=this.validateGestureState();if(1==s&&(s=this.validatePointerManagerState(t)),1==s&&(s=this.validateButton(t)),!0===s){if(1!=t.lastInputSessionPointerCount)return!1;{const e=t.getlastRemovedPointerInput();s=e instanceof g&&this.validateGestureParameters(e)}}return s}onStart(t){this.setInitialPointerEvent(t),this.emit(t)}}class b extends M{static minDuration=600;constructor(t,s){super(t,s),this.eventBaseName="press";let e=600,i=10,n=20;s&&("minDuration"in s&&(e=s.minDuration),"maxDistance"in s&&(n=s.maxDistance,i=s.maxDistance)),this.initialParameters.global.min.duration=e,this.initialParameters.global.max.distance=i,this.initialParameters.global.max.maximumDistance=n,this.hasBeenEmitted=!1}recognize(t){const s=this.validate(t),e=this.getPointerInput(t),n=this.initialParameters.global.min.duration||b.minDuration;e instanceof g&&(1==s&&0==this.hasBeenEmitted?(this.setInitialPointerEvent(t),this.emit(t),this.hasBeenEmitted=!0,this.state=i.Active,this.blockGestures()):0==s&&1==this.hasBeenEmitted?(this.onEnd(t),this.state=i.Inactive,this.hasBeenEmitted=!1):1==this.hasBeenEmitted&&e.parameters.global.duration<=n&&(this.hasBeenEmitted=!1)),null==e&&(this.hasBeenEmitted=!1)}}class D extends M{constructor(t,s){super(t,s),this.validPointerManagerState=h.SinglePointer,this.eventBaseName="pan",this.initialParameters.global.min.duration=0,this.initialParameters.live.min.distance=10,this.initialParameters.global.boolean.hasBeenMoved=!0,this.swipeFinalSpeed=600,this.isSwipe=!1,this.options.supportedDirections=s?.supportedDirections??e.All,this.initialSupportedDirections=this.options.supportedDirections}validate(t){return this.state==i.Active&&(this.options.supportedDirections=e.All),super.validate(t)}onStart(t){this.isSwipe=!1,super.onStart(t)}onEnd(s){const e=s.getlastRemovedPointerInput();e instanceof g&&(this.swipeFinalSpeed<e.parameters.global.finalSpeed&&e.parameters.live.vector.direction!=t.None?(this.isSwipe=!0,this.emit(s,"swipe")):1==this.DEBUG&&(e.parameters.global.finalSpeed<this.swipeFinalSpeed?console.log(`[Pan] dismissing swipe. Final speed: ${e.parameters.global.finalSpeed} < ${this.swipeFinalSpeed}`):console.log(`[Pan] dismissing swipe. Direction: ${e.parameters.live.vector.direction}`))),super.onEnd(s),this.options.supportedDirections=this.initialSupportedDirections}onTouchMove(t){this.state==i.Active&&(1==this.DEBUG&&console.log("[Pan] preventing touchmove default"),t.preventDefault(),t.stopPropagation())}}class E{constructor(t,s){this.pointerIds=new Set([t.pointerId,s.pointerId]),this.startTimestamp=(new Date).getTime(),this.pointerMap={},this.pointerMap[t.pointerId]=t,this.pointerMap[s.pointerId]=s,this.pointer_1=t,this.pointer_2=s,this.initialPointerEvent=t.initialPointerEvent,this.currentPointerEvent=t.initialPointerEvent;const e=this.pointer_1.parameters.global.vector,i=this.pointer_2.parameters.global.vector,n={duration:0,center:u.getCenter(e.startPoint,i.startPoint),centerHasBeenMoved:!1,centerMovementDistance:0,centerMovementVector:u.getCenterMovementVector(e,i),absolutePointerDistanceChange:0,relativePointerDistanceChange:0,rotationAngle:0,absoluteRotationAngle:0,vectorAngle:0,absoluteVectorAngle:0},h=this.pointer_1.parameters.live.vector,o=this.pointer_2.parameters.live.vector,r=u.getCenter(h.startPoint,o.startPoint),a=u.getCenterMovementVector(h,o);this.parameters={global:n,live:{center:r,centerIsMoving:!1,centerMovementDistance:0,centerMovementVector:a,absolutePointerDistanceChange:0,relativePointerDistanceChange:0,rotationAngle:0,absoluteRotationAngle:0,vectorAngle:0,absoluteVectorAngle:0}}}removePointer(t){if(t==this.pointer_1.pointerId)return this.pointer_2;if(t==this.pointer_2.pointerId)return this.pointer_1;throw new Error(`[DualPointerInput] cannot remove Pointer #${t}. The pointer is not part of this DualPointerInput`)}getTarget(){return this.initialPointerEvent.target}update(t){t instanceof PointerEvent&&(this.currentPointerEvent=t);const s=(new Date).getTime();this.parameters.global.duration=s-this.startTimestamp;const e=this.pointer_1.parameters.global.vector,i=this.pointer_2.parameters.global.vector,n=u.getCenter(e.startPoint,i.startPoint),h=u.getCenterMovementVector(e,i),o=u.calculateAbsoluteDistanceChange(e,i),r=u.calculateRelativeDistanceChange(e,i),a=u.calculateRotationAngle(e,i),c=u.calculateVectorAngle(e,i);this.parameters.global.center=n,this.parameters.global.centerMovementVector=h,this.parameters.global.centerMovementDistance=h.vectorLength,this.parameters.global.absolutePointerDistanceChange=o,this.parameters.global.relativePointerDistanceChange=r,this.parameters.global.rotationAngle=a,this.parameters.global.absoluteRotationAngle=Math.abs(a),this.parameters.global.vectorAngle=c,this.parameters.global.absoluteVectorAngle=Math.abs(c);const l=this.pointer_1.parameters.live.vector,d=this.pointer_2.parameters.live.vector,p=u.getCenter(l.startPoint,d.startPoint),v=u.getCenterMovementVector(l,d),g=u.calculateAbsoluteDistanceChange(l,d),P=u.calculateRelativeDistanceChange(l,d),f=u.calculateRotationAngle(l,d),m=u.calculateVectorAngle(l,d);v.vectorLength>0?(this.parameters.live.centerIsMoving=!0,this.parameters.global.centerHasBeenMoved=!0):this.parameters.live.centerIsMoving=!1,this.parameters.live.center=p,this.parameters.live.centerMovementDistance=v.vectorLength,this.parameters.live.centerMovementVector=v,this.parameters.live.absolutePointerDistanceChange=g,this.parameters.live.relativePointerDistanceChange=P,this.parameters.live.rotationAngle=f,this.parameters.live.absoluteRotationAngle=Math.abs(f),this.parameters.live.vectorAngle=m,this.parameters.live.absoluteVectorAngle=Math.abs(m)}onPointerMove(t){this.update(t)}onPointerUp(t){this.update(t)}onPointerLeave(t){this.update(t)}onPointerCancel(t){this.update(t)}onIdle(){this.update()}getCurrentDirection(){return this.parameters.live.centerMovementVector.direction}getCurrentPointerEvent(){return this.currentPointerEvent}}class G extends w{constructor(t,s){super(t,s),this.initialPointerEvent_1=null,this.initialPointerEvent_2=null,this.validPointerManagerState=h.DualPointer,this.validPointerInputConstructor=E;const e=this.getEmptyGestureParameters();this.initialParameters={...e},this.activeStateParameters=JSON.parse(JSON.stringify({...e}))}getEventData(t,s){const e=t.parameters.global,i=t.parameters.live;return{recognizer:this,global:{deltaX:e.centerMovementVector.x,deltaY:e.centerMovementVector.y,distance:e.centerMovementDistance,speedX:e.centerMovementVector.x/e.duration,speedY:e.centerMovementVector.y/e.duration,speed:e.centerMovementVector.vectorLength/e.duration,direction:e.centerMovementVector.direction,scale:e.relativePointerDistanceChange,rotation:e.rotationAngle,center:e.center,srcEvent:t.currentPointerEvent},live:{deltaX:i.centerMovementVector.x,deltaY:i.centerMovementVector.y,distance:i.centerMovementDistance,speedX:i.centerMovementVector.x/e.duration,speedY:i.centerMovementVector.y/e.duration,speed:i.centerMovementVector.vectorLength/e.duration,direction:i.centerMovementVector.direction,scale:i.relativePointerDistanceChange,rotation:i.rotationAngle,center:{x:i.centerMovementVector.startPoint.x,y:i.centerMovementVector.startPoint.y},srcEvent:t.currentPointerEvent},pointerManager:s}}}class I extends G{constructor(t,s){super(t,s),this.eventBaseName="pinch",this.initialParameters.live.min.centerMovementDistance=0,this.initialParameters.live.max.centerMovementDistance=50,this.initialParameters.live.min.absolutePointerDistanceChange=5,this.initialParameters.live.max.absoluteRotationAngle=20,this.initialParameters.live.min.absoluteVectorAngle=10}}class S extends G{constructor(t,s){super(t,s),this.eventBaseName="rotate",this.initialParameters.live.min.centerMovementDistance=0,this.initialParameters.live.max.centerMovementDistance=50,this.initialParameters.live.max.absolutePointerDistanceChange=50,this.initialParameters.live.min.absoluteRotationAngle=5,this.activeStateParameters.live.min.absoluteRotationAngle=0}}class x extends G{constructor(t,s){super(t,s),this.eventBaseName="twofingerpan",this.initialParameters.live.min.centerMovementDistance=10,this.initialParameters.live.max.absolutePointerDistanceChange=50,this.initialParameters.live.max.absoluteVectorAngle=150,this.activeStateParameters.live.min.centerMovementDistance=0}}class C{constructor(t){t=t||{},this.options={DEBUG:!1,...t},this.DEBUG=this.options.DEBUG,this.state=h.NoPointer,this.activePointerInput=null,this.lastRemovedPointer=null,this.lastInputSessionPointerCount=0,this.pointerAllocation={},this.unusedPointers={},this.onSurfacePointers={}}addPointer(t){1==this.DEBUG&&console.log(`[PointerManager] adding Pointer #${t.pointerId.toString()}`);const s=new v(t,{DEBUG:this.DEBUG});this.onSurfacePointers[s.pointerId]=s,null==this.activePointerInput?this.setActiveSinglePointerInput(s):this.activePointerInput instanceof g?this.setActiveDualPointerInput(this.activePointerInput.pointer,s):this.activePointerInput instanceof E&&(this.unusedPointers[s.pointerId]=s),this.lastInputSessionPointerCount=this.currentPointerCount()}removePointer(t){if(1==this.DEBUG&&(console.log(`[PointerManager] starting to remove Pointer #${t}`),console.log(`[PointerManager] state: ${this.state}`)),this.lastRemovedPointer=this.onSurfacePointers[t],delete this.onSurfacePointers[t],t in this.unusedPointers&&delete this.unusedPointers[t],this.activePointerInput instanceof E){if(this.activePointerInput.pointerIds.has(t)){1==this.DEBUG&&console.log(`[PointerManager] removing Pointer #${t} from DualPointerInput`);const s=this.activePointerInput.removePointer(t);this.activePointerInput=null;const e=this.getUnusedPointer();e instanceof v?this.setActiveDualPointerInput(s,e):this.setActiveSinglePointerInput(s)}}else if(this.activePointerInput instanceof g){if(1==this.DEBUG&&console.log(`[PointerManager] removing Pointer #${t} from SinglePointerInput`),this.activePointerInput=null,this.state=h.NoPointer,Object.keys(this.unusedPointers).length>0)throw this.unusedPointers={},new Error("[PointerManager] found unused Pointers although there should not be any");if(Object.keys(this.onSurfacePointers).length>0)throw this.onSurfacePointers={},new Error("[PointerManager] found onSurfacePointers although there should not be any")}1==this.DEBUG&&console.log(`[PointerManager] state: ${this.state}`)}setActiveSinglePointerInput(t){t.reset();const s=new g(t);this.activePointerInput=s,this.pointerAllocation[t.pointerId]=s,delete this.unusedPointers[t.pointerId],this.state=h.SinglePointer,1==this.DEBUG&&console.log(`[PointerManager] state: ${this.state}`)}setActiveDualPointerInput(t,s){t.reset(),s.reset();const e=new E(t,s);this.activePointerInput=e,this.pointerAllocation[t.pointerId]=e,this.pointerAllocation[s.pointerId]=e,delete this.unusedPointers[t.pointerId],delete this.unusedPointers[s.pointerId],this.state=h.DualPointer,1==this.DEBUG&&console.log(`[PointerManager] state: ${this.state}`)}hasPointersOnSurface(){return Object.keys(this.onSurfacePointers).length>0}currentPointerCount(){return Object.keys(this.onSurfacePointers).length}getUnusedPointer(){return Object.keys(this.unusedPointers).length>0?Object.values(this.unusedPointers)[0]:null}getPointerFromId(t){return t in this.onSurfacePointers?this.onSurfacePointers[t]:null}getlastRemovedPointerInput(){return this.lastRemovedPointer instanceof v?this.pointerAllocation[this.lastRemovedPointer.pointerId]:null}onIdle(){for(const t in this.onSurfacePointers)this.onSurfacePointers[t].onIdle();this.activePointerInput?.onIdle()}onPointerMove(t){const s=this.getPointerFromId(t.pointerId);s instanceof v&&s.onPointerMove(t),this.activePointerInput?.onPointerMove(t)}onPointerUp(t){1==this.DEBUG&&console.log("[PointerManager] pointerup detected");const s=this.getPointerFromId(t.pointerId);s instanceof v&&s.onPointerUp(t),this.activePointerInput?.onPointerUp(t),this.removePointer(t.pointerId)}onPointerCancel(t){1==this.DEBUG&&console.log("[PointerManager] pointercancel detected");const s=this.getPointerFromId(t.pointerId);s instanceof v&&s.onPointerCancel(t),this.activePointerInput?.onPointerCancel(t),this.removePointer(t.pointerId)}}const T=[$,b,D,I,S,x];class A{constructor(t,s){this.state=r.NoActiveGesture,this.activeGestures=[],this.hadActiveGestureDuringCurrentContact=!1,this.gestureEventHandlers={},this.lastRecognitionTimestamp=null,this.idleRecognitionIntervalId=null,this.pointerEventHandlers={},this.touchEventHandlers={},s=s||{},this.options={DEBUG:!1,DEBUG_GESTURES:!1,DEBUG_POINTERMANAGER:!1,bubbles:!0,handleTouchEvents:!0,consecutiveGestures:!0,simultaneousGestures:!0,supportedGestures:[],...s},this.DEBUG=this.options.DEBUG;const e=(s.supportedGestures??T).map((s=>{if("function"==typeof s)return new s(t,{bubbles:this.options.bubbles,DEBUG:this.options.DEBUG_GESTURES});if("object"==typeof s)return s;throw new Error("unsupported gesture type: "+typeof s)}));this.supportedGestures=e,this.domElement=t,this.pointerManager=new C({DEBUG:this.options.DEBUG_POINTERMANAGER}),this.addPointerEventListeners(),this.addTouchEventListeners()}addPointerEventListeners(){const t=this.domElement,s=this.onPointerDown.bind(this),e=this.onPointerMove.bind(this),i=this.onPointerUp.bind(this),n=this.onPointerCancel.bind(this);t.addEventListener("pointerdown",s,{passive:!0}),t.addEventListener("pointermove",e,{passive:!0}),t.addEventListener("pointerup",i,{passive:!0}),t.addEventListener("pointercancel",n,{passive:!0}),this.pointerEventHandlers={pointerdown:s,pointermove:e,pointerup:i,pointercancel:n}}onPointerDown(t){1==this.DEBUG&&console.log("[PointerListener] pointerdown event detected"),(t.target||this.domElement).setPointerCapture(t.pointerId),this.pointerManager.addPointer(t),this.options.pointerdown?.(t,this),null!=this.idleRecognitionIntervalId&&this.clearIdleRecognitionInterval(),this.idleRecognitionIntervalId=setInterval((()=>{this.onIdle()}),100)}onPointerMove(t){1==this.pointerManager.hasPointersOnSurface()&&(this.pointerManager.onPointerMove(t),this.recognizeGestures(),this.options.pointermove?.(t,this))}onPointerUp(t){1==this.DEBUG&&console.log("[PointerListener] pointerup event detected"),this.domElement.releasePointerCapture(t.pointerId),1==this.pointerManager.hasPointersOnSurface()&&(this.pointerManager.onPointerUp(t),this.recognizeGestures(),this.options.pointerup?.(t,this)),this.clearIdleRecognitionInterval()}onPointerCancel(t){this.domElement.releasePointerCapture(t.pointerId),1==this.DEBUG&&console.log("[PointerListener] pointercancel detected"),this.pointerManager.onPointerCancel(t),this.recognizeGestures(),this.clearIdleRecognitionInterval(),this.options.pointercancel?.(t,this)}removePointerEventListeners(){for(const t in this.pointerEventHandlers)this.domElement.removeEventListener(t,this.pointerEventHandlers[t])}addTouchEventListeners(){if(1==this.options.handleTouchEvents){const t=this.onTouchMove.bind(this);this.domElement.addEventListener("touchmove",t),this.touchEventHandlers.touchmove=t}}removeTouchEventListeners(){for(const t in this.touchEventHandlers)this.domElement.removeEventListener(t,this.touchEventHandlers[t])}onTouchMove(t){for(let s=0;s<this.supportedGestures.length;s++)this.supportedGestures[s].onTouchMove(t)}onIdle(){if(0==this.pointerManager.hasPointersOnSurface())this.clearIdleRecognitionInterval();else{const t=(new Date).getTime();let s=null;null!=this.lastRecognitionTimestamp&&(s=t-this.lastRecognitionTimestamp),(null==s||s>100)&&(this.pointerManager.onIdle(),1==this.DEBUG&&console.log("[PointerListener] onIdle - running idle recognition"),this.recognizeGestures())}}clearIdleRecognitionInterval(){null!=this.idleRecognitionIntervalId&&(clearInterval(this.idleRecognitionIntervalId),this.idleRecognitionIntervalId=null)}recognizeGestures(){this.lastRecognitionTimestamp=(new Date).getTime();let t=this.supportedGestures;0==this.options.simultaneousGestures&&this.state==r.ActiveGesture||0==this.options.consecutiveGestures&&this.state==r.ActiveGesture?t=[this.activeGestures[0]]:0==this.options.consecutiveGestures&&this.state==r.NoActiveGesture&&1==this.hadActiveGestureDuringCurrentContact&&1==this.pointerManager.hasPointersOnSurface()&&(t=[]);for(let s=0;s<t.length;s++){const e=t[s];if(e.recognize(this.pointerManager),this.updateActiveGestures(e),0==this.options.simultaneousGestures&&this.state==r.ActiveGesture)break}1==this.DEBUG&&console.log(`[PointerListener] hadActiveGestureDuringCurrentContact: ${this.hadActiveGestureDuringCurrentContact}`),0==this.pointerManager.hasPointersOnSurface()&&(this.hadActiveGestureDuringCurrentContact=!1)}updateActiveGestures(t){if(t.state==i.Active)this.hadActiveGestureDuringCurrentContact=!0,this.activeGestures.indexOf(t)<0&&this.activeGestures.push(t);else{const s=this.activeGestures.indexOf(t);s>=0&&this.activeGestures.splice(s,1)}this.state=this.activeGestures.length>0?r.ActiveGesture:r.NoActiveGesture}parseEventsString(t){return t.trim().split(/\s+/g)}on(t,s){const e=this.parseEventsString(t);for(let t=0;t<e.length;t++){const i=e[t];i in this.gestureEventHandlers||(this.gestureEventHandlers[i]=[]),-1==this.gestureEventHandlers[i].indexOf(s)&&this.gestureEventHandlers[i].push(s),this.domElement.addEventListener(i,s,{capture:!1,passive:!0})}}off(t,s){const e=this.parseEventsString(t);1==this.DEBUG&&(console.log(`[PointerListener] turning off events: ${t}`),console.log(this.gestureEventHandlers));for(let t=0;t<e.length;t++){const i=e[t];if(i in this.gestureEventHandlers){const t=this.gestureEventHandlers[i],e=t.indexOf(s);1==this.DEBUG&&console.log(`[PointerListener] turning off ${i}. Index on handlerList: ${e}`),e>=0&&(t.splice(e,1),this.gestureEventHandlers[i]=t),this.domElement.removeEventListener(i,s,!1)}}}destroy(){for(const t in this.gestureEventHandlers){const s=this.gestureEventHandlers[t];for(let e=0;e<s.length;e++)this.domElement.removeEventListener(t,s[e]);delete this.gestureEventHandlers[t]}this.removePointerEventListeners(),this.removeTouchEventListeners()}}export{t as Direction,e as Directions,u as Geometry,m as GestureEvent,i as GestureState,D as Pan,I as Pinch,A as PointerListener,r as PointerListenerState,h as PointerManagerState,d as PointerState,b as Press,S as Rotate,$ as Tap,x as TwoFingerPan}